//This file is auto generated by Project Reflect, please do not edit this file.
#include "..\src\core.h"
#include "..\src\entity\camera.h"
#include "..\src\entity\controller.h"
#include "..\src\entity\light.h"
#include "..\src\entity\object.h"
#include "..\src\entity\scene.h"
#include "..\src\entity\terrain.h"
#include "..\src\entity\transformer.h"
#include "..\src\entity\water.h"
#include "..\src\image_data.h"
#include "..\src\math\math.h"
#include "..\src\model\animation.h"
#include "..\src\model\material.h"
#include "..\src\model\model.h"
#include "..\src\physics\physics.h"
#include "..\src\render\buffer.h"
#include "..\src\render\command_buffer.h"
#include "..\src\render\descriptor.h"
#include "..\src\render\framebuffer.h"
#include "..\src\render\image.h"
#include "..\src\render\pipeline.h"
#include "..\src\render\push_constant.h"
#include "..\src\render\renderpass.h"
#include "..\src\render\sampler.h"
#include "..\src\render\shader.h"
#include "..\src\render\synchronization.h"
#include "..\src\render\vulkan.h"
#include "..\src\resource\resource.h"
#include "..\src\sound\sound.h"
#include "..\src\ui\ui.h"
#include "..\src\utils.h"
#include "..\src\window.h"
namespace tke{
float near_plane = 0.1f;
float far_plane = 1000.f;
float fovy = 60.f;
int nowTime;
std::string enginePath;
int resCx;
int resCy;
float screenAspect;
glm::mat4 matOrtho;
glm::mat4 matOrthoInv;
glm::mat4 matPerspective;
glm::mat4 matPerspectiveInv;
StagingBuffer *stagingBuffer = nullptr;
bool needUpdateVertexBuffer;
bool needUpdateMaterialBuffer;
bool needUpdateTexture;
std::vector<std::pair<std::string,Image*>> debugImages;
std::vector<std::unique_ptr<Image>> textures;
std::vector<std::unique_ptr<Image>> modelTextures;
std::vector<Material*> modelMaterials;
Material *defaultMaterial = nullptr;
std::vector<std::unique_ptr<Animation>> animations;
std::vector<std::unique_ptr<Model>> models;
std::vector<std::unique_ptr<Scene>> scenes;
VertexBuffer *staticVertexBuffer = nullptr;
IndexBuffer *staticIndexBuffer = nullptr;
VertexBuffer *animatedVertexBuffer = nullptr;
IndexBuffer *animatedIndexBuffer = nullptr;
UniformBuffer *constantBuffer = nullptr;
UniformBuffer *materialBuffer = nullptr;
Image *plainDepthImage = nullptr;
Image *pickUpImage = nullptr;
RenderPass *renderPass_image8 = nullptr;
RenderPass *renderPass_image8_clear = nullptr;
RenderPass *renderPass_image16 = nullptr;
RenderPass *renderPass_image16_clear = nullptr;
RenderPass *renderPass_depth_clear = nullptr;
RenderPass *renderPass_depth_clear_image8 = nullptr;
RenderPass *renderPass_depth_clear_image8_clear = nullptr;
RenderPass *renderPass_depth_clear_image32f_clear = nullptr;
std::shared_ptr<Framebuffer> pickUpFb;
Pipeline *plainPipeline_2d = nullptr;
Pipeline *plainPipeline_3d = nullptr;
Pipeline *plainPipeline_3d_anim = nullptr;
Pipeline *plainPipeline_3d_normal = nullptr;
Pipeline *plainPipeline_3d_tex = nullptr;
Pipeline *plainPipeline_3d_anim_tex = nullptr;
Pipeline *plainPipeline_3d_wire = nullptr;
Pipeline *plainPipeline_3d_anim_wire = nullptr;
Pipeline *plainPipeline_3d_line = nullptr;
DescriptorSet *ds_maps = nullptr;
HWND hWnd;
int window_cx;
int window_cy;
KeyState mouseLeft;
KeyState mouseMiddle;
KeyState mouseRight;
int mouseX;
int mouseY;
int mousePrevX;
int mousePrevY;
int mouseDispX;
int mouseDispY;
int mouseScroll;
KeyState keyStates[256];
VkSurfaceKHR window_surface;
VkSwapchainKHR swapchain;
Image *window_images[2];
std::shared_ptr<Framebuffer> window_framebuffers[2];
VkSemaphore window_imageAvailable;
uint32_t window_imageIndex;
std::vector<VkCommandBuffer> cbs;
VkFence frameDone;
uint32_t FPS;
PF_EVENT1 onKeyDown;
PF_EVENT1 onKeyUp;
PF_EVENT1 onChar;
PF_EVENT2 onMouseLeftDown;
PF_EVENT2 onMouseLeftUp;
PF_EVENT2 onMouseMiddleDown;
PF_EVENT2 onMouseMiddleUp;
PF_EVENT2 onMouseRightDown;
PF_EVENT2 onMouseRightUp;
PF_EVENT2 onMouseMove;
PF_EVENT1 onMouseWheel;
PF_EVENT0 onRender;
GuiComponent *ui;
tke::ReflectionBank *Controller::b = tke::addReflectionBank("Controller");
tke::ReflectionBank *Object::b = tke::addReflectionBank("Object");
Pipeline *scatteringPipeline = nullptr;
Pipeline *downsamplePipeline = nullptr;
Pipeline *convolvePipeline = nullptr;
Pipeline *mrtPipeline = nullptr;
Pipeline *mrtAnimPipeline = nullptr;
Pipeline *terrainPipeline = nullptr;
Pipeline *waterPipeline = nullptr;
Pipeline *proceduralTerrainPipeline = nullptr;
Pipeline *deferredPipeline = nullptr;
Pipeline *esmPipeline = nullptr;
Pipeline *esmAnimPipeline = nullptr;
Pipeline *composePipeline = nullptr;
tke::ReflectionBank *Scene::b = tke::addReflectionBank("Scene");
tke::ReflectionBank *Terrain::b = tke::addReflectionBank("Terrain");
tke::ReflectionBank *Transformer::b = tke::addReflectionBank("Transformer");
tke::ReflectionBank *Water::b = tke::addReflectionBank("Water");
tke::ReflectionBank *Model::b = tke::addReflectionBank("Model");
VkPipelineVertexInputStateCreateInfo zeroVertexInputState;
VkPipelineVertexInputStateCreateInfo plain2dVertexInputState;
VkPipelineVertexInputStateCreateInfo vertexInputState;
VkPipelineVertexInputStateCreateInfo animatedVertexInputState;
VkPipelineVertexInputStateCreateInfo lineVertexInputState;
tke::ReflectionBank *PushConstantRange::b = tke::addReflectionBank("PushConstantRange");
std::vector<std::weak_ptr<Shader>> loaded_shaders;
bool uiAcceptedMouse;
bool uiAcceptedKey;
CommandBuffer *ui_cb;
std::vector<VkEvent> ui_waitEvents;
struct ReflectInit{ReflectInit(){
tke::EnumType *currentEnumType = nullptr;
tke::ReflectionBank *currentBank = nullptr;
currentEnumType = tke::addReflectEnumType("ObjectPhysicsType");
currentEnumType->items.emplace_back("null", (int)ObjectPhysicsType::null);
currentEnumType->items.emplace_back("static_r", (int)ObjectPhysicsType::static_r);
currentEnumType->items.emplace_back("dynamic", (int)ObjectPhysicsType::dynamic);
currentEnumType->items.emplace_back("controller", (int)ObjectPhysicsType::controller);
currentEnumType = tke::addReflectEnumType("SamplerType");
currentEnumType->items.emplace_back("none", (int)SamplerType::none);
currentEnumType->items.emplace_back("plain", (int)SamplerType::plain);
currentEnumType->items.emplace_back("plain_unnormalized", (int)SamplerType::plain_unnormalized);
currentEnumType->items.emplace_back("color", (int)SamplerType::color);
currentEnumType->items.emplace_back("color_border", (int)SamplerType::color_border);
currentBank = Controller::b;
currentBank->addV<float>("ang_offset", offsetof(Controller, ang_offset));
currentBank->addV<float>("speed", offsetof(Controller, speed));
currentBank->addV<float>("turn_speed", offsetof(Controller, turn_speed));
currentBank = Object::b;
currentBank->parents.emplace_back(Controller::b, TK_STRUCT_OFFSET(Object, Controller));
currentBank->addV<std::string>("model_filename", offsetof(Object, model_filename));
currentBank->addV<std::string>("name", offsetof(Object, name));
currentBank->addE("ObjectPhysicsType", "physics_type", offsetof(Object, physics_type));
currentBank = Scene::b;
currentBank->addV<std::string>("name", offsetof(Scene, name));
currentBank = Terrain::b;
currentBank->addV<bool>("use_physx", offsetof(Terrain, use_physx));
currentBank->addV<std::string>("blend_map_filename", offsetof(Terrain, blend_map_filename));
currentBank->addV<std::string>("height_map_filename", offsetof(Terrain, height_map_filename));
currentBank->addV<std::string>("color_map0_filename", offsetof(Terrain, color_map0_filename));
currentBank->addV<std::string>("color_map1_filename", offsetof(Terrain, color_map1_filename));
currentBank->addV<std::string>("color_map2_filename", offsetof(Terrain, color_map2_filename));
currentBank->addV<std::string>("color_map3_filename", offsetof(Terrain, color_map3_filename));
currentBank->addV<std::string>("normal_map0_filename", offsetof(Terrain, normal_map0_filename));
currentBank->addV<std::string>("normal_map1_filename", offsetof(Terrain, normal_map1_filename));
currentBank->addV<std::string>("normal_map2_filename", offsetof(Terrain, normal_map2_filename));
currentBank->addV<std::string>("normal_map3_filename", offsetof(Terrain, normal_map3_filename));
currentBank->addV<int>("block_cx", offsetof(Terrain, block_cx));
currentBank->addV<float>("block_size", offsetof(Terrain, block_size));
currentBank->addV<float>("height", offsetof(Terrain, height));
currentBank->addV<float>("tessellation_factor", offsetof(Terrain, tessellation_factor));
currentBank->addV<float>("texture_uv_factor", offsetof(Terrain, texture_uv_factor));
currentBank = Transformer::b;
currentBank->addV<glm::vec3>("coord", offsetof(Transformer, coord));
currentBank->addV<glm::vec3>("euler", offsetof(Transformer, euler));
currentBank->addV<glm::vec3>("scale", offsetof(Transformer, scale));
currentBank = Water::b;
currentBank->parents.emplace_back(Transformer::b, TK_STRUCT_OFFSET(Water, Transformer));
currentBank = Model::b;
currentBank->addV<std::string>("stand_animation_filename", offsetof(Model, stand_animation_filename));
currentBank->addV<std::string>("forward_animation_filename", offsetof(Model, forward_animation_filename));
currentBank->addV<std::string>("leftward_animation_filename", offsetof(Model, leftward_animation_filename));
currentBank->addV<std::string>("rightward_animation_filename", offsetof(Model, rightward_animation_filename));
currentBank->addV<std::string>("backward_animation_filename", offsetof(Model, backward_animation_filename));
currentBank->addV<std::string>("jump_animation_filename", offsetof(Model, jump_animation_filename));
currentBank->addV<glm::vec3>("controller_position", offsetof(Model, controller_position));
currentBank->addV<float>("controller_height", offsetof(Model, controller_height));
currentBank->addV<float>("controller_radius", offsetof(Model, controller_radius));
currentBank->addV<glm::vec3>("eye_position", offsetof(Model, eye_position));
currentBank = PushConstantRange::b;
currentBank->addV<int>("offset", offsetof(PushConstantRange, offset));
currentBank->addV<int>("size", offsetof(PushConstantRange, size));
}};static ReflectInit _init;
}